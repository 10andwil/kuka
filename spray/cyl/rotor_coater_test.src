&ACCESS RVP
&REL 11
&PARAM TEMPLATE = C:\KRC\Roboter\Template\vorgabe
&PARAM EDITMASK = *
DEF rotor_coater_test( )
REAL step

;INITIALIZE TIMERS (DEVELOPED BY AW 2022-09-19)
;DECL INT ONETHIRD, TWOTHIRDS, ONEQUARTER, ONEHALF, THREEQUARTERS 
$TIMER_STOP[1]=FALSE ;starts timer 1. unit is milliseconds
$TIMER_STOP[2]=FALSE
$TIMER_STOP[3]=FALSE
$TIMER_STOP[4]=FALSE ;starts timer 1. unit is milliseconds
$TIMER_STOP[5]=FALSE
$TIMER_STOP[6]=FALSE
;$TIMER_FLAG[1]=FALSE; it switches to true when timer 1 changes from positive to negative
;$TIMER_FLAG[2]=FALSE
;$TIMER_FLAG[3]=FALSE

$CYCFLAG[1] = $TIMER_FLAG[1] AND NOT $TIMER_FLAG[4] ; COULD USE EXOR? 
$CYCFLAG[2] = $TIMER_FLAG[2] AND NOT $TIMER_FLAG[5]
$CYCFLAG[3] = $TIMER_FLAG[3] AND NOT $TIMER_FLAG[6]

INTERRUPT DECL 1 WHEN $TIMER[1]>1201 DO RESET_TIMERS() ;81 is the priority, below the automatic allocations for the robot system
INTERRUPT ON 1

RESET_TIMERS ()

;FOLD INI
  ;FOLD BASISTECH INI

    GLOBAL INTERRUPT DECL 3 WHEN $STOPMESS==TRUE DO IR_STOPM ( )
	INTERRUPT ON 3 
    BAS (#INITMOV,0 )
  ;ENDFOLD (BASISTECH INI)
  ;FOLD USER INI
    ;Make your modifications here

  ;ENDFOLD (USER INI)
;ENDFOLD (INI)

;FOLD PTP HOME CONT Vel=50 % DEFAULT;%{PE}%R 5.6.13,%MKUKATPBASIS,%CMOVE,%VPTP,%P 1:PTP, 2:HOME, 3:C_PTP, 5:50, 7:DEFAULT
$BWDSTART=FALSE
PDAT_ACT=PDEFAULT
FDAT_ACT=FHOME
BAS(#PTP_PARAMS,50)
$H_POS=XHOME
PTP XHOME C_PTP
;ENDFOLD

	;FOLD ; go north east & 8" above workpiece;%{PE}%R 5.6.13,%MKUKATPBASIS,%CCOMMENT,%VNORMAL,%P 2:go north east & 8" above workpiece
	;ENDFOLD
;FOLD PTP P2 Vel=50 % PDAT3 Tool[6]:Spray Gun Base[6]:Spray Gun Base;%{PE}%R 5.6.13,%MKUKATPBASIS,%CMOVE,%VPTP,%P 1:PTP, 2:P2, 3:, 5:50, 7:PDAT3
$BWDSTART=FALSE
PDAT_ACT=PPDAT3
FDAT_ACT=FP2
BAS(#PTP_PARAMS,50)
PTP XP2 
;ENDFOLD

	;FOLD ; turn on solenoid;%{PE}%R 5.6.13,%MKUKATPBASIS,%CCOMMENT,%VNORMAL,%P 2:turn on solenoid
	;ENDFOLD
;FOLD SYN OUT 33 'solenoid' State=TRUE at START Delay=0 ms;%{PE}%R 5.6.13,%MKUKATPBASIS,%COUT,%VSYNOUT,%P 2:33, 3:solenoid, 5:TRUE, 7:0, 9:0, 12:0
TRIGGER WHEN DISTANCE=0 DELAY=0 DO $OUT[33]=TRUE
;ENDFOLD

;FOLD SYN OUT 33 'solenoid' State=FALSE at END Delay=1000 ms;%{PE}%R 5.6.13,%MKUKATPBASIS,%COUT,%VSYNOUT,%P 2:33, 3:solenoid, 5:FALSE, 7:1, 9:0, 12:1000
TRIGGER WHEN DISTANCE=1 DELAY=1000 DO $OUT[33]=FALSE
;ENDFOLD
	;FOLD WAIT Time=1 sec;%{PE}%R 5.6.13,%MKUKATPBASIS,%CWAIT,%VWAIT,%P 2:1
	WAIT SEC 1
	;ENDFOLD

$VEL.CP=0.030

	;FOLD ; first pass at edge of workpiece;%{PE}%R 5.6.13,%MKUKATPBASIS,%CCOMMENT,%VNORMAL,%P 2:first pass at edge of workpiece
	;ENDFOLD


WAIT FOR $TIMER_FLAG[1] AND NOT $TIMER_FLAG[4]
LIN_REL {Y -150}


;FOLD WAIT Time=1 sec;%{PE}%R 5.6.13,%MKUKATPBASIS,%CWAIT,%VWAIT,%P 2:1
WAIT SEC 1
;ENDFOLD



;FOLD SYN OUT 33 'solenoid' State=FALSE at END Delay=0 ms;%{PE}%R 5.6.13,%MKUKATPBASIS,%COUT,%VSYNOUT,%P 2:33, 3:solenoid, 5:FALSE, 7:1, 9:0, 12:0
TRIGGER WHEN DISTANCE=1 DELAY=0 DO $OUT[33]=FALSE
;ENDFOLD
$VEL.CP=0.1
LIN_REL {Z 10}
LIN_REL {Y 150}

LIN_REL {Z -10}


;FOLD WAIT Time=1 sec;%{PE}%R 5.6.13,%MKUKATPBASIS,%CWAIT,%VWAIT,%P 2:1
WAIT SEC 1
;ENDFOLD


;FOLD SYN OUT 33 '' State=TRUE at START Delay=0 ms;%{PE}%R 5.6.13,%MKUKATPBASIS,%COUT,%VSYNOUT,%P 2:33, 3:, 5:TRUE, 7:0, 9:0, 12:0
	TRIGGER WHEN DISTANCE=0 DELAY=0 DO $OUT[33]=TRUE
	;ENDFOLD
	
;FOLD SYN OUT 33 'solenoid' State=FALSE at END Delay=0 ms;%{PE}%R 5.6.13,%MKUKATPBASIS,%COUT,%VSYNOUT,%P 2:33, 3:solenoid, 5:FALSE, 7:1, 9:0, 12:0
TRIGGER WHEN DISTANCE=1 DELAY=0 DO $OUT[33]=FALSE
;ENDFOLD
$VEL.CP=0.03

; $CYCFLAG[1] = TIMER[1]>16633
; $CYCFLAG[1] = FALSE
; ; SOME KIND OF INTERRUPT THAT RESESTS TIMER 1 TO ZERO AND CYCFLAGS TO FALSE
; WAIT FOR CYCFLAG[1]

WAIT FOR $TIMER_FLAG[2] AND NOT $TIMER_FLAG[5]
LIN_REL {Y -150}
	
;FOLD WAIT Time=1 sec;%{PE}%R 5.6.13,%MKUKATPBASIS,%CWAIT,%VWAIT,%P 2:1
WAIT SEC 1
;ENDFOLD

;FOLD SYN OUT 33 'solenoid' State=FALSE at END Delay=0 ms;%{PE}%R 5.6.13,%MKUKATPBASIS,%COUT,%VSYNOUT,%P 2:33, 3:solenoid, 5:FALSE, 7:1, 9:0, 12:0
TRIGGER WHEN DISTANCE=1 DELAY=0 DO $OUT[33]=FALSE
;ENDFOLD
$VEL.CP=0.1
LIN_REL {Z 10}
LIN_REL {Y 150}
LIN_REL {Z -10}

;FOLD WAIT Time=1 sec;%{PE}%R 5.6.13,%MKUKATPBASIS,%CWAIT,%VWAIT,%P 2:1
WAIT SEC 1
;ENDFOLD

;FOLD SYN OUT 33 '' State=TRUE at START Delay=0 ms;%{PE}%R 5.6.13,%MKUKATPBASIS,%COUT,%VSYNOUT,%P 2:33, 3:, 5:TRUE, 7:0, 9:0, 12:0
	TRIGGER WHEN DISTANCE=0 DELAY=0 DO $OUT[33]=TRUE
	;ENDFOLD
	
;FOLD SYN OUT 33 'solenoid' State=FALSE at END Delay=0 ms;%{PE}%R 5.6.13,%MKUKATPBASIS,%COUT,%VSYNOUT,%P 2:33, 3:solenoid, 5:FALSE, 7:1, 9:0, 12:0
TRIGGER WHEN DISTANCE=1 DELAY=0 DO $OUT[33]=FALSE
;ENDFOLD

$VEL.CP=0.03

WAIT FOR $TIMER_FLAG[3] AND NOT $TIMER_FLAG[6]
; we could try
;WAIT FOR $CYCFLAG[15]
;WITH

LIN_REL {Y -150}

;FOLD WAIT Time=1 sec;%{PE}%R 5.6.13,%MKUKATPBASIS,%CWAIT,%VWAIT,%P 2:1
WAIT SEC 1
;ENDFOLD

;FOLD PTP HOME Vel=50 % DEFAULT;%{PE}%R 5.6.13,%MKUKATPBASIS,%CMOVE,%VPTP,%P 1:PTP, 2:HOME, 3:, 5:50, 7:DEFAULT
$BWDSTART=FALSE
PDAT_ACT=PDEFAULT
FDAT_ACT=FHOME
BAS(#PTP_PARAMS,50)
$H_POS=XHOME
PTP XHOME 
;ENDFOLD



END

DEF RESET_TIMERS ()
;$TIMER_FLAG[1]=FALSE; it switches to true when timer 1 changes from positive to negative
;$TIMER_FLAG[2]=FALSE
;$TIMER_FLAG[3]=FALSE
$TIMER[1] = -1
$TIMER[2] = -401 ; ONE THIRD
$TIMER[3] = -802 ; TWO THIRDS
$TIMER[4] = -1-12
$TIMER[5] = -401-12
$TIMER[6] = -802-12
END